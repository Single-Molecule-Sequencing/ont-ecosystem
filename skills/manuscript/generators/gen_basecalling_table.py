#!/usr/bin/env python3
"""
Generate basecalling statistics table.

Creates a formatted table of basecalling performance metrics.

Usage:
    gen_basecalling_table.py <experiment_id> --output <path> --format <tex|csv|json|html>
"""

import argparse
import json
import sys
from pathlib import Path

# Add parent directories to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent / "bin"))

try:
    from ont_context import load_experiment_context
    HAS_CONTEXT = True
except ImportError:
    HAS_CONTEXT = False


def format_number(value, precision=1):
    """Format number with commas and optional precision"""
    if value is None:
        return "N/A"
    if isinstance(value, float):
        return f"{value:,.{precision}f}"
    if isinstance(value, int):
        return f"{value:,}"
    return str(value)


def format_bases(bases):
    """Format bases with appropriate unit (Kb, Mb, Gb)"""
    if bases is None:
        return "N/A"
    if bases >= 1e9:
        return f"{bases/1e9:.2f} Gb"
    elif bases >= 1e6:
        return f"{bases/1e6:.2f} Mb"
    elif bases >= 1e3:
        return f"{bases/1e3:.2f} Kb"
    return f"{bases} bp"


def generate_basecalling_table(ctx, output_path: Path, format: str = "tex"):
    """
    Generate basecalling statistics table from experiment context.

    Args:
        ctx: ExperimentContext object
        output_path: Output file path
        format: Output format (tex, csv, json, html)

    Returns:
        Path to generated file
    """
    # Build table data
    rows = [
        ("Experiment", ctx.name),
        ("Experiment ID", ctx.id),
    ]

    if ctx.statistics:
        rows.extend([
            ("Total Reads", format_number(ctx.statistics.total_reads)),
            ("Total Bases", format_bases(ctx.statistics.total_bases)),
            ("Pass Reads", format_number(ctx.statistics.pass_reads)),
            ("Fail Reads", format_number(ctx.statistics.fail_reads)),
            ("Mean Read Length", format_number(ctx.statistics.mean_length, 0) + " bp"),
            ("N50", format_number(ctx.statistics.n50) + " bp"),
            ("Mean Q-Score", format_number(ctx.statistics.mean_qscore)),
            ("Median Q-Score", format_number(ctx.statistics.median_qscore)),
        ])

        # Calculate pass rate
        if ctx.statistics.total_reads > 0:
            pass_rate = ctx.statistics.pass_reads / ctx.statistics.total_reads * 100
            rows.append(("Pass Rate", f"{pass_rate:.1f}%"))

    # Quality grade
    if ctx.quality_grade:
        rows.append(("Quality Grade", ctx.quality_grade))

    # Write output
    output_path = Path(output_path)

    if format == "json":
        data = {row[0]: row[1] for row in rows}
        with open(output_path, "w") as f:
            json.dump(data, f, indent=2)

    elif format == "csv":
        with open(output_path, "w") as f:
            f.write("Metric,Value\n")
            for metric, value in rows:
                value_str = str(value).replace(",", "")
                f.write(f"{metric},{value_str}\n")

    elif format == "tex":
        with open(output_path, "w") as f:
            f.write("% Basecalling Statistics Table\n")
            f.write("% Generated by ONT Manuscript Studio\n")
            f.write("\\begin{table}[htbp]\n")
            f.write("\\centering\n")
            f.write("\\caption{Basecalling Statistics: " + _latex_escape(ctx.name) + "}\n")
            f.write("\\label{tab:basecalling_" + ctx.id.replace("-", "_") + "}\n")
            f.write("\\begin{tabular}{ll}\n")
            f.write("\\toprule\n")
            f.write("\\textbf{Metric} & \\textbf{Value} \\\\\n")
            f.write("\\midrule\n")

            for metric, value in rows:
                f.write(f"{_latex_escape(metric)} & {_latex_escape(str(value))} \\\\\n")

            f.write("\\bottomrule\n")
            f.write("\\end{tabular}\n")
            f.write("\\end{table}\n")

    elif format == "html":
        with open(output_path, "w") as f:
            f.write("<!-- Basecalling Statistics Table -->\n")
            f.write("<!-- Generated by ONT Manuscript Studio -->\n")
            f.write('<table class="basecalling-stats">\n')
            f.write("  <caption>Basecalling Statistics: " + _html_escape(ctx.name) + "</caption>\n")
            f.write("  <thead>\n")
            f.write("    <tr><th>Metric</th><th>Value</th></tr>\n")
            f.write("  </thead>\n")
            f.write("  <tbody>\n")

            for metric, value in rows:
                f.write(f"    <tr><td>{_html_escape(metric)}</td><td>{_html_escape(str(value))}</td></tr>\n")

            f.write("  </tbody>\n")
            f.write("</table>\n")

    return output_path


def _latex_escape(text: str) -> str:
    """Escape special LaTeX characters"""
    replacements = {
        '&': r'\&', '%': r'\%', '$': r'\$', '#': r'\#',
        '_': r'\_', '{': r'\{', '}': r'\}',
    }
    for char, replacement in replacements.items():
        text = text.replace(char, replacement)
    return text


def _html_escape(text: str) -> str:
    """Escape HTML special characters"""
    replacements = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;'}
    for char, replacement in replacements.items():
        text = text.replace(char, replacement)
    return text


def main():
    parser = argparse.ArgumentParser(description="Generate basecalling statistics table")
    parser.add_argument("experiment_id", help="Experiment ID")
    parser.add_argument("--output", "-o", required=True, help="Output path")
    parser.add_argument("--format", default="tex", choices=["tex", "csv", "json", "html"],
                       help="Output format")

    args = parser.parse_args()

    if not HAS_CONTEXT:
        print("Error: ont_context module required")
        sys.exit(1)

    ctx = load_experiment_context(args.experiment_id)
    if ctx is None:
        print(f"Error: Experiment not found: {args.experiment_id}")
        sys.exit(1)

    output_path = Path(args.output)
    result = generate_basecalling_table(ctx, output_path, args.format)

    if result:
        print(f"Generated: {result}")
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
