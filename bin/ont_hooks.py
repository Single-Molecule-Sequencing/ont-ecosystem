#!/usr/bin/env python3
"""
ONT Ecosystem Git Hooks Manager - Setup and manage git hooks

Usage:
    ont_hooks.py install           # Install all hooks
    ont_hooks.py uninstall         # Remove all hooks
    ont_hooks.py list              # List available hooks
    ont_hooks.py status            # Show installed hooks status
    ont_hooks.py run <hook>        # Run a specific hook manually
"""

import argparse
import os
import stat
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Add paths
bin_dir = Path(__file__).parent
lib_dir = bin_dir.parent / 'lib'
sys.path.insert(0, str(bin_dir))
sys.path.insert(0, str(lib_dir.parent))

try:
    from lib import __version__
except ImportError:
    __version__ = "3.0.0"


# Hook definitions
HOOKS = {
    "pre-commit": {
        "description": "Run before each commit",
        "checks": ["syntax", "tests-quick"],
        "script": r'''#!/bin/bash
# ONT Ecosystem Pre-commit Hook
# Auto-generated by ont_hooks.py

set -e

echo "Running pre-commit checks..."

# Get repository root
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Check Python syntax for staged files
echo "Checking Python syntax..."
STAGED_PY=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)
if [ -n "$STAGED_PY" ]; then
    for file in $STAGED_PY; do
        if [ -f "$file" ]; then
            python -m py_compile "$file" 2>&1 || {
                echo "Syntax error in $file"
                exit 1
            }
        fi
    done
    echo "  Syntax OK"
else
    echo "  No Python files staged"
fi

# Run quick tests if available
if [ -d "tests" ]; then
    echo "Running quick tests..."
    python -m pytest tests/ -x -q --tb=line 2>&1 | tail -5 || {
        echo "Tests failed - commit aborted"
        exit 1
    }
fi

echo "Pre-commit checks passed!"
''',
    },

    "pre-push": {
        "description": "Run before pushing to remote",
        "checks": ["tests-full", "lint"],
        "script": '''#!/bin/bash
# ONT Ecosystem Pre-push Hook
# Auto-generated by ont_hooks.py

set -e

echo "Running pre-push checks..."

# Get repository root
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Run full test suite
if [ -d "tests" ]; then
    echo "Running full test suite..."
    python -m pytest tests/ -v --tb=short 2>&1 | tail -20 || {
        echo "Tests failed - push aborted"
        exit 1
    }
fi

echo "Pre-push checks passed!"
''',
    },

    "commit-msg": {
        "description": "Validate commit message format",
        "checks": ["message-format"],
        "script": '''#!/bin/bash
# ONT Ecosystem Commit Message Hook
# Auto-generated by ont_hooks.py

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Check minimum length
MIN_LENGTH=10
MSG_LENGTH=${#COMMIT_MSG}

if [ $MSG_LENGTH -lt $MIN_LENGTH ]; then
    echo "Error: Commit message too short (minimum $MIN_LENGTH characters)"
    exit 1
fi

# Check first line length
FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1)
FIRST_LINE_LENGTH=${#FIRST_LINE}

if [ $FIRST_LINE_LENGTH -gt 72 ]; then
    echo "Warning: First line of commit message exceeds 72 characters"
    # Warning only, don't block
fi

exit 0
''',
    },

    "post-checkout": {
        "description": "Run after checkout/branch switch",
        "checks": ["dependencies"],
        "script": '''#!/bin/bash
# ONT Ecosystem Post-checkout Hook
# Auto-generated by ont_hooks.py

# Arguments: previous_head new_head is_branch_checkout
PREV_HEAD=$1
NEW_HEAD=$2
IS_BRANCH=$3

# Only run on branch checkout, not file checkout
if [ "$IS_BRANCH" != "1" ]; then
    exit 0
fi

# Get repository root
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Check if requirements changed
if git diff --name-only "$PREV_HEAD" "$NEW_HEAD" | grep -q "requirements"; then
    echo ""
    echo "Note: requirements files changed. You may need to run:"
    echo "  pip install -r requirements.txt"
    echo ""
fi

# Check if pyproject.toml changed
if git diff --name-only "$PREV_HEAD" "$NEW_HEAD" | grep -q "pyproject.toml"; then
    echo ""
    echo "Note: pyproject.toml changed. You may need to run:"
    echo "  pip install -e ."
    echo ""
fi
''',
    },

    "post-merge": {
        "description": "Run after merge",
        "checks": ["dependencies"],
        "script": '''#!/bin/bash
# ONT Ecosystem Post-merge Hook
# Auto-generated by ont_hooks.py

# Get repository root
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Check if requirements changed
CHANGED=$(git diff-tree -r --name-only ORIG_HEAD HEAD)

if echo "$CHANGED" | grep -q "requirements"; then
    echo ""
    echo "Note: requirements files changed. You may need to run:"
    echo "  pip install -r requirements.txt"
    echo ""
fi

if echo "$CHANGED" | grep -q "pyproject.toml"; then
    echo ""
    echo "Note: pyproject.toml changed. You may need to run:"
    echo "  pip install -e ."
    echo ""
fi
''',
    },
}


def get_git_hooks_dir() -> Optional[Path]:
    """Get the git hooks directory"""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            capture_output=True, text=True
        )
        if result.returncode == 0:
            git_dir = Path(result.stdout.strip())
            return git_dir / "hooks"
    except Exception:
        pass
    return None


def get_installed_hooks() -> Dict[str, bool]:
    """Get status of installed hooks"""
    hooks_dir = get_git_hooks_dir()
    if not hooks_dir:
        return {}

    installed = {}
    for hook_name in HOOKS:
        hook_path = hooks_dir / hook_name
        installed[hook_name] = (
            hook_path.exists() and
            os.access(hook_path, os.X_OK)
        )
    return installed


def install_hook(hook_name: str, force: bool = False) -> Tuple[bool, str]:
    """Install a single hook"""
    if hook_name not in HOOKS:
        return False, f"Unknown hook: {hook_name}"

    hooks_dir = get_git_hooks_dir()
    if not hooks_dir:
        return False, "Not a git repository"

    hooks_dir.mkdir(exist_ok=True)
    hook_path = hooks_dir / hook_name

    # Check if hook exists and is not ours
    if hook_path.exists() and not force:
        content = hook_path.read_text()
        if "ONT Ecosystem" not in content:
            return False, f"Hook {hook_name} exists (use --force to overwrite)"

    # Write hook script
    hook_path.write_text(HOOKS[hook_name]["script"])

    # Make executable
    hook_path.chmod(hook_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    return True, f"Installed {hook_name}"


def uninstall_hook(hook_name: str) -> Tuple[bool, str]:
    """Uninstall a single hook"""
    hooks_dir = get_git_hooks_dir()
    if not hooks_dir:
        return False, "Not a git repository"

    hook_path = hooks_dir / hook_name
    if not hook_path.exists():
        return True, f"Hook {hook_name} not installed"

    # Only remove if it's ours
    content = hook_path.read_text()
    if "ONT Ecosystem" not in content:
        return False, f"Hook {hook_name} not managed by ONT Ecosystem"

    hook_path.unlink()
    return True, f"Uninstalled {hook_name}"


def run_hook(hook_name: str) -> Tuple[bool, str]:
    """Run a hook manually"""
    hooks_dir = get_git_hooks_dir()
    if not hooks_dir:
        return False, "Not a git repository"

    hook_path = hooks_dir / hook_name
    if not hook_path.exists():
        return False, f"Hook {hook_name} not installed"

    try:
        result = subprocess.run(
            [str(hook_path)],
            capture_output=True, text=True
        )
        output = result.stdout + result.stderr
        if result.returncode == 0:
            return True, output
        else:
            return False, output
    except Exception as e:
        return False, str(e)


def cmd_install(args):
    """Install hooks"""
    print("Installing git hooks...")

    hooks_to_install = args.hooks if args.hooks else list(HOOKS.keys())

    results = []
    for hook_name in hooks_to_install:
        success, msg = install_hook(hook_name, force=args.force)
        status = "✅" if success else "❌"
        print(f"  {status} {msg}")
        results.append(success)

    if all(results):
        print("\nAll hooks installed successfully!")
        return 0
    else:
        print("\nSome hooks failed to install")
        return 1


def cmd_uninstall(args):
    """Uninstall hooks"""
    print("Uninstalling git hooks...")

    hooks_to_uninstall = args.hooks if args.hooks else list(HOOKS.keys())

    results = []
    for hook_name in hooks_to_uninstall:
        success, msg = uninstall_hook(hook_name)
        status = "✅" if success else "❌"
        print(f"  {status} {msg}")
        results.append(success)

    if all(results):
        print("\nAll hooks uninstalled successfully!")
        return 0
    else:
        print("\nSome hooks failed to uninstall")
        return 1


def cmd_list(args):
    """List available hooks"""
    print("Available git hooks:")
    print("-" * 60)

    for hook_name, hook_info in HOOKS.items():
        print(f"\n  {hook_name}")
        print(f"    Description: {hook_info['description']}")
        print(f"    Checks: {', '.join(hook_info['checks'])}")


def cmd_status(args):
    """Show hook status"""
    print("Git hooks status:")
    print("-" * 60)

    installed = get_installed_hooks()

    if not installed:
        print("Not a git repository or no hooks directory")
        return 1

    for hook_name in HOOKS:
        is_installed = installed.get(hook_name, False)
        status = "✅ Installed" if is_installed else "⭕ Not installed"
        print(f"  {hook_name}: {status}")

    installed_count = sum(1 for v in installed.values() if v)
    print(f"\n{installed_count}/{len(HOOKS)} hooks installed")

    return 0


def cmd_run(args):
    """Run a hook manually"""
    hook_name = args.hook

    if hook_name not in HOOKS:
        print(f"Unknown hook: {hook_name}")
        return 1

    print(f"Running {hook_name}...")
    print("-" * 60)

    success, output = run_hook(hook_name)
    print(output)

    if success:
        print("-" * 60)
        print("Hook completed successfully")
        return 0
    else:
        print("-" * 60)
        print("Hook failed")
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="ONT Ecosystem Git Hooks Manager",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    # install
    p_install = subparsers.add_parser('install', help='Install hooks')
    p_install.add_argument('hooks', nargs='*', help='Specific hooks to install')
    p_install.add_argument('--force', '-f', action='store_true',
                           help='Overwrite existing hooks')
    p_install.set_defaults(func=cmd_install)

    # uninstall
    p_uninstall = subparsers.add_parser('uninstall', help='Uninstall hooks')
    p_uninstall.add_argument('hooks', nargs='*', help='Specific hooks to uninstall')
    p_uninstall.set_defaults(func=cmd_uninstall)

    # list
    p_list = subparsers.add_parser('list', help='List available hooks')
    p_list.set_defaults(func=cmd_list)

    # status
    p_status = subparsers.add_parser('status', help='Show hook status')
    p_status.set_defaults(func=cmd_status)

    # run
    p_run = subparsers.add_parser('run', help='Run a hook manually')
    p_run.add_argument('hook', help='Hook to run')
    p_run.set_defaults(func=cmd_run)

    args = parser.parse_args()
    sys.exit(args.func(args))


if __name__ == "__main__":
    main()
